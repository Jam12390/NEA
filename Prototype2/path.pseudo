//note to self, make sure to include a direction in the parameters for findIntermediatePath
//to 1. improve efficiency and 2. actually know in which direction to look for an intermediate path in
def findIntermediatePath(
        screen,
        walls,
        initialNodePos,
        nodeDistance,
        xMapOffset, 
        yMapOffset,
        startNode,
        jumpHeight,
        jumpRadius,
        xGraphLimit
    ):

    circleSightRadius = 70//deg (70deg left and right)

    lineStartx = initialNodePos + (startNode[1] * nodeDistance) - xMapOffset
    lineStarty = initialNodePos + (startNode[0] * nodeDistance) - yMapOffset
    lineStart = (lineStartx, lineStarty)
    lineEnd = (lineStartx, lineStarty-jumpHeight) //y-coordinates are reversed in pygame
    
    jumpLine = pygame.draw.line(
        surface=screen,
        color=(255,255,255),
        start_pos=lineStart,
        end_pos=lineEnd
    )

    collided = false
    lineNodex = startNode[1]
    lineNodey = startNode[0]

    while (NOT collided) AND xGraphLimit[0] <= lineNodex AND lineNodex <= xGraphLimit[1]: //xGraphLimit[leftLim, rightLim]
        jumpLine.move(-nodeDistance, 0)
        lineNodex -= 1
        for wall in walls:
            if pygame.Rect.colliderect(wall, jumpLine):
                collided = true
                jumpLine.move(nodeDistance, 0)
                lineNodex += 1
                break
    
    platformFound = [false, null, null] //[found, direction, node]

    if collided:
        circleCenterx = lineStartx + ((startNode[1]-lineNodex) * nodeDistance)
        jumpCircle = pygame.draw.circle(surface=screen, color=(0,0,255), center=(circleCenterx, lineStarty), radius=jumpRadius)
        leftCollisionState = [false, false] //[previous, current]
        rightCollisionState = [false, false]

        previousChordState = null

        while circleSightRadius > 0 AND NOT platformFound[0]:
            chordLength = round(math.sqrt((2*jumpRadius**2)*(1-math.cosine(2*circleSightRadius))))
            chordHeight = round(jumpRadius*math.cosine(circleSightRadius))
            leftChordEnd = (circleCenterx - chordLength DIV 2, lineStarty + chordHeight) //assume DIV = //
            rightChordEnd = (circleCenterx + chordLength DIV 2, lineStarty + chordHeight)

            leftCollisionState[0] = leftCollisionState[1] //move "current" state to previous state
            rightCollisionState[0] = rightCollisionState[1]

            leftCollidedWith = null
            rightCollidedWith = null

            for wall in walls:
                if pygame.Rect.collidepoint(wall, leftChordEnd):
                    leftCollisionState[1] = true
                    leftCollidedWith = wall
                    break
                else:
                    leftCollisionState[1] = false
                    leftCollidedWith = null
            
            for wall in walls:
                if pygame.Rect.collidepoint(wall, rightChordEnd):
                    rightCollisionState[1] = true
                    rightCollidedWith = wall
                    break
                else:
                    rightCollisionState[1] = false
                    rightCollidedWith = null
            
            if leftCollisionState[0] AND NOT leftCollisionState[1]: //true -> false collision
                found = testCollisionChange(previousChordState, leftChordEnd, chordHeight, "l")
                if found:
                    platformFound = [true, "l"]

            previousChordState = {
                "leftChord": leftChordEnd,
                "leftCollidedWith": leftCollidedWith,
                "rightChord": rightChordEnd,
                "rightCollidedWith": rightCollidedWith,
                "chordHeight": chordHeight
            }


def testCollisionChange(previousState, pointToTest, currentChordHeight, direction):
            if direction == "l":
                queries = ["leftChord", "leftCollidedWith"]
            else:
                queries = ["rightChord", "rightCollidedWith"]
            
            loweredChord = (previousState[queries[0]][0], previousState[queries[0]][1] - currentChordHeight + previousState["chordHeight"]) //move the point down to the previous chord's height
            if pygame.Rect.collidepoint(previousState[queries[1]], loweredChord): //and test its collision against the wall the previous wall collided with
                //TODO: add a function for getting the edge node of the found platform
                return true
            else:
                return false