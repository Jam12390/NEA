def getAdjacentNodes(nodeMap, nodeIndex, limits):
    adj = [
        (nodeIndex[0] - 1, nodeIndex[1]),
        (nodeIndex[0] + 1, nodeIndex[1]),
        (nodeIndex[0], nodeIndex[1] - 1),
        (nodeIndex[0], nodeIndex[1] + 1)
    ]
    indexesToRemove = []

    for index in range(0, 4):
        if limits["x"][0] <= adj[index][0] AND adj[index][0] <= limits["x"][1]:
            inXRange = true
        else:
            inXRange = false
        if limits["y"][0] <= adj[index][1] AND adj[index][1] <= limits["y"][1]:
            inYRange = true
        else:
            inYRange = false

        if nodeMap[adj[index][1]][adj[index][0]] == "#" OR NOT inXRange OR NOT inYRange:
            indexesToRemove.append(index)
    
    for index in indexesToRemove:
        adj.remove(index)
    
    return adj
    
def path(
    nodeMap,
    limits,
    startNode, //in index form i.e. [y, x] where the origin is the top left. (cannot be a tuple due to tuples being static)
    endNode,
    excludedNodes=[],
    preVerified=false,
    savedState=null
    ):

    currentTable = {
        startNode: {
            "shortestDistance": 0,
            "heuristic": math.sqrt((endNode[0]-startNode[0])**2 + (endNode[1]-startNode[1]**2)),
            "nextNodes": [],
            "previousNode": NA,
            "visited": false
        },
        endNode: {
            "shortestDistance": math.inf,
            "heuristic": 0,
            "nextNodes": NA,
            "previousNode": null,
            "visited": false
        }
    }
    
    pathFound = false

    while NOT pathFound:
        nextToVisit = [null, math.inf] //[node, distance]
        for node in currentTable.keys:
            if node["shortestDistance"] + node["heuristic"] < nextToVisit AND NOT (node["visited"] OR node in excludedNodes):
                nextToVisit = [node, node["shortestDistance"] + node["heuristic"]]
        
        adjacentNodes = getAdjacentNodes(nodeMap, nextToVisit[0], limits) //TODO: continue here